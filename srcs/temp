typedef struct s_camera
{
	t_vec3	look_at;
	double	yaw;
	double	pitch;
	double	zoom;
	double	aspect_ratio;
	double	fov;
	int		valid;
}			t_camera;

typedef struct s_ray
{
	t_vec3	origin;
	t_vec3	direction;
    t_vec3  right;
    t_vec3  up;
}			t_ray;

void	init_camera(t_camera *cam, t_vec3 pos, t_vec3 forward)
{
	t_vec3	dir_2d;

	cam->look_at = vec3_add(pos, vec3_multf(forward, cam->zoom));

	dir_2d = vec3_sub(pos, cam->look_at);
	dir_2d.y = 0;
	vec3_normalize(&dir_2d);
	cam->yaw = atan2(dir_2d.z, dir_2d.x);
	dir_2d = vec3_sub(pos, cam->look_at);
	dir_2d.x = 0;
	vec3_normalize(&dir_2d);
	cam->pitch = atan2(dir_2d.y, dir_2d.z);
    right = vec3_cross(get_camera_direction(cam), (t_vec3){0, 1, 0});
    rel_up = vec3_cross(right, get_camera_direction(cam));
}

t_vec3	get_direction_to_cam(t_camera *cam)
{
	t_vec3	yaw_pos;
	t_vec3	pitch_pos;
	t_vec3	dir;

	yaw_pos.x = cos(cam->yaw);
	yaw_pos.y = 0;
	yaw_pos.z = sin(cam->yaw);
	pitch_pos.x = 0;
	pitch_pos.y = sin(cam->pitch);
	pitch_pos.z = cos(cam->pitch);

	dir = vec3_add(yaw_pos, pitch_pos);
	vec3_normalize(&dir);
	return (dir);
}

t_vec3	get_camera_direction(t_camera *cam)
{
	t_vec3	dir;

	dir = vec3_multf(get_direction_to_cam(cam), -1.0);
	return (dir);
}

t_vec3	get_camera_position(t_camera *cam)
{
	t_vec3	pos;

	pos = vec3_multf(get_direction_to_cam(cam), cam->zoom);
	pos = vec3_add(pos, cam->look_at);
	return (pos);
}

t_ray	create_primary_ray(t_camera *cam, t_vec2 pxl)
{
	t_ray	primary_ray;
	double	norm_coord_x;
	double	norm_coord_y;

	norm_coord_x = ((2.0 * (pxl.x + 0.5) / WIDTH)) * cam->aspect_ratio * tan(M_PI_4);
	norm_coord_y = (1 - (2.0 * (pxl.y + 0.5) / HEIGHT)) * tan(M_PI_4);
	primary_ray.origin = get_camera_position(cam);
	primary_ray.direction = get_camera_direction(cam);
	return (primary_ray);
}

t_ray create_primary_ray(t_camera *cam, t_vec2 pxl)
{
    t_ray primary_ray;
    double norm_coord_x;
    double norm_coord_y;

    norm_coord_x = ((2.0 * (pxl.x + 0.5) / WIDTH) - 1.0) * cam->aspect_ratio * tan(cam->fov * 0.5);
    norm_coord_y = (1.0 - (2.0 * (pxl.y + 0.5) / HEIGHT)) * tan(cam->fov * 0.5);
    primary_ray.direction = vec3_add(vec3_multf(cam.right, norm_coord_x), vec3_multf(cam.up, norm_coord_y));
    vec3_normalize(primary_ray.direction);

    return primary_ray;
}
